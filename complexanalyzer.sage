# this file generates a series of PNG images and saves them to a directory,
# which can serve as the basis for a video generated by ffmpeg (.avi),
# sage (.apng), or ImageMagick (.gif)

import sage.symbolic.function
import sage.plot.colors
import itertools
import operator
import os
import subprocess
import time
from datetime import datetime
from pprint import pprint
from sage.plot.animate import APngAssembler
from subprocess import PIPE
from subprocess import Popen
from subprocess import call

class PlotMethod:
    SCATTER = 1
    LINE = 2
    RECTANGLE = 4

class ComplexAnalyzer:
    def __init__(self,tmin=0,tmax=100,dt=0.1,xmin=-10,xmax=10,ymin=-10,ymax=10,headlights=True,dirpath='archive',filenameformat='strip_{}.png',sigmasamplefactor=1,tsamplefactor=1,fn=zeta,plotmethod=PlotMethod.SCATTER):
        self.dt = dt
        self.tmin = tmin
        self.tmax = tmax
        self.tcurr = tmin
        self.tsamplefactor = tsamplefactor
        self.tnumsamples = 32 * tsamplefactor
        if self.tnumsamples < 1:
            raise ValueError, "tsamplefactor cannot be smaller than 1/32"
        self.sigmasamplefactor = sigmasamplefactor
        self.sigmanumsamples = 64 * sigmasamplefactor
        if self.sigmanumsamples < 1:
            raise ValueError, "sigmasamplefactor cannot be smaller than 1/64"
        self.blendfactor = 1 / sigmasamplefactor
        self.xmin = xmin
        self.xmax = xmax
        if self.xmin >= self.xmax:
            raise ValueError, "xmin must be less than xmax"
        self.ymin = ymin
        self.ymax = ymax
        if self.ymin >= self.ymax:
            raise ValueError, "ymin must be less than ymax"
        self.headlights = headlights
        if os.path.exists(dirpath) == False:
            os.makedirs(dirpath)
        self.dirpath = dirpath
        self.filenameformat = filenameformat
        ds = 1 / (self.sigmanumsamples - 1)
        self.cachedstrips = []
        self.maxcachedstrips = self.tnumsamples
        self.fn = fn
        #self.plotmethod = plotmethod
        if plotmethod == PlotMethod.SCATTER:
            self.include = self.includeall
            #self.fade = self.leadingfade
            self.graphic_g = self.point_g
        elif plotmethod == PlotMethod.LINE:
            self.include = self.includecurrent
            #self.fade = self.nofade
            self.graphic_g = self.line_g
        elif plotmethod == PlotMethod.RECTANGLE:
            self.include = self.includeperimeter
            #self.fade = self.nofade
            self.graphic_g = self.rectangle_g
        else:
            raise ValueError, "The plot method specified is undefined, please use SCATTER, LINE, or RECTANGLE"
        self.sigmaarray = [i*ds for i in range(self.sigmanumsamples)]
        self.colorarray64 = [
            '#BF9100', '#BF9B00', '#C0A500', '#C0AE00', '#C1B800', '#C1C200', '#B8C200', '#B0C300',
            '#A7C300', '#9EC400', '#95C500', '#8CC500', '#83C600', '#7AC600', '#71C700', '#68C800',
            '#5FC800', '#55C900', '#4CC900', '#42CA00', '#39CB00', '#2FCB00', '#26CC00', '#1CCC00',
            '#13CD00', '#09CE00', '#00CE00', '#00CF0A', '#00CF14', '#00D01E', '#00D128', '#00D132',
            '#00D23C', '#00D246', '#00D351', '#00D45B', '#00D465', '#00D570', '#00D57A', '#00D685',
            '#00D78F', '#00D79A', '#00D8A5', '#00D8B0', '#00D9BA', '#00DAC5', '#00DAD0', '#00DADB',
            '#00D0DB', '#00C7DC', '#00BDDD', '#00B3DD', '#00A8DE', '#009EDE', '#0094DF', '#008AE0',
            '#007FE0', '#0075E1', '#006BE1', '#0060E2', '#0056E3', '#004BE3', '#0040E4', '#0035E5']
        return

    def color_g(self):
        for i in range(self.sigmanumsamples):
            #print "iterating color_g [{}]".format(i)
            i = int(i/self.sigmasamplefactor)
            if (i+1) < len(self.colorarray64):
                color_a = Color(self.colorarray64[i])
                color_b = Color(self.colorarray64[(i+1)])
                yield color_a.blend(color_b,fraction=(i%self.sigmasamplefactor)*self.blendfactor)
            else:
                yield Color(self.colorarray64[len(self.colorarray64)-1])

    def strip_g(self):
        stack = []
        # define generator to evaluate self.fn (used from point_g)
        for i in range(self.tnumsamples):
            #print "strip_g i: {}".format(i)
            if i < len(self.cachedstrips):
                # self.cachedstrips is a queue, but we want the most recently calculated
                # strips returned first, so pull from the back
                #print "cached strip discovered at index [{}]".format(len(self.cachedstrips)-(i+1))
                #yield self.cachedstrips[-(i+1)]
                stack.append(self.cachedstrips[i])
            else:
                #print "cache miss"
                strip = []
                self.tcurr += self.dt
                for j, (sigma) in enumerate(self.sigmaarray):
                    s = complex(sigma,self.tcurr)
                    z = self.fn(s)
                    strip.append(z)
                self.tcurr = self.tcurr + self.dt
                self.cachedstrips.append(strip)
                if len(self.cachedstrips) >= self.maxcachedstrips:
                    self.cachedstrips.pop(0)
                #yield strip
                stack.append(strip)
        while len(stack) > 0:
            yield stack.pop()

    def includeall(self,i,j):
        return True

    def includecurrent(self,i,j):
        if (i+1) == self.tnumsamples:
            return True
        return False

    def includeperimeter(self,i,j):
        if i == 0 or (i+1) == self.tnumsamples:
            return True
        elif j == 0 or (j+1) == self.sigmanumsamples:
            return True
        return False

    def nofade(self,i,j):
        return 1

    def leadingfade(self,i,j):
        return 1 / (self.tnumsamples - i)

    def trailingfade(self,i,j):
        return 1 / (i+1)

    def point_g(self):
        ## define point generator (used from plot_g)
        zg = self.strip_g()
        for i, (strip) in enumerate(zg):
            #print "t: {}, strip: {}".format(self.tcurr, str(strip))
            #print "i: {}, strip: {}".format(i, str(strip))
            cg = self.color_g()
            for j, (color,z) in enumerate(itertools.izip(cg,strip)):
                if self.include(i,j):
                    x = real_part(z)
                    y = imag_part(z)
                    c = Color(color)
                    plottitle = "t = {}".format(self.tcurr - (self.maxcachedstrips * self.dt))
                    #print "point(({},{}),xmin={},xmax={},ymin={},ymax={},rgbcolor={},alpha={})".format(x,y,self.xmin,self.xmax,self.ymin,self.ymax,c,1/(i+1))
                    #yield point((x,y),xmin=self.xmin,xmax=self.xmax,ymin=self.ymin,ymax=self.ymax,rgbcolor=color,alpha=1/(i+1))
                    # whether the fade leads or trails the current line can be set simply by adjusting alpha relative to i
                    # i.e., alpha = 1/(i+1) => trailing fade
                    #       alpha = 1/(self.tnumsamples-i) => leading fade
                    yield point((x,y),xmin=self.xmin,xmax=self.xmax,ymin=self.ymin,ymax=self.ymax,rgbcolor=color,alpha=self.leadingfade(i,j),title=plottitle)

    def line_g(self):
        zg = self.strip_g()
        for i, (strip) in enumerate(zg):
            cg = self.color_g()
            p0 = None
            p1 = None
            for j, (color,z) in enumerate(itertools.izip(cg,strip)):
                if self.include(i,j):
                    x = real_part(z)
                    y = imag_part(z)
                    if p0 == None:
                        p0 = [x, y]
                    else:
                        p1 = [x, y]
                        c = Color(color)
                        plottitle = "t = {}".format(self.tcurr - (self.maxcachedstrips * self.dt))
                        yield line([p0, p1],xmin=self.xmin,xmax=self.xmax,ymin=self.ymin,ymax=self.ymax,rgbcolor=color,alpha=self.nofade(i,j),title=plottitle)

    def rectangle_g(self):
        zg = self.strip_g()
        color = (1/8,3/4,1/2)
        l = []
        for i, (strip) in enumerate(zg):
            for j, (z) in enumerate(strip):
                if self.include(i,j):
                    x = real_part(z)
                    y = imag_part(z)
                    l.append([x, y])
        plottitle = "t = {}".format(self.tcurr - (self.maxcachedstrips * self.dt))
        yield polygon(l,xmin=self.xmin,xmax=self.xmax,ymin=self.ymin,ymax=self.ymax,rgbcolor=color,title=plottitle)

    def plot_g(self):
        # with this definition, this generator will terminate once a look-ahead strip is calculated
        # thus, the value for t of the final plot will be less than the value of tmax
        lookaheadmax = self.tmax + (self.tnumsamples * self.dt)
        while self.tcurr < lookaheadmax:
            g = self.graphic_g()
            composite = None
            for graphic in g:
                if composite == None:
                    composite = graphic
                else:
                    composite += graphic
            yield composite

    def createpng(self,plot,id):
        filename = os.path.join(self.dirpath, self.filenameformat.format(id))
        if plot == None:
            print "Unable to create file with id [{}]: {}".format(id,filename)
            return None
        plot.save_image(filename)
        return filename
  
    def apngstrategy(self,vfile,paths,keeptmpfiles,extend):
        with open(vfile, "wb") as f:
            apng = APngAssembler(f, len(paths))
            for png in paths:
                apng.add_frame(png, delay=1, delay_denominator=30)
                #if keeptmpfiles == False:
                #    os.unlink(png)
        return

    def avistrategy(self,vfile,paths,keeptmpfiles,extend):
        # NOTE - this method can only be used if the files are jpg
        # convert from png => jpg
        args = ['mogrify','-format','jpg',os.path.join(self.dirpath,'*.png')]
        subprocess.call(args)
        #ffmpeg -i frame%04d.png -c:v huffyuv test.avi
        fps = 10
        #cat *.jpg | ffmpeg -f image2pipe -r 1/5 -c:v mjpeg -i - -c:v copy -f matroska - | ffplay -
        # alternatively...
        #cat *.jpg | ffmpeg -f image2pipe -r 1 -c:v mjpeg -i - -c:v libx264 -r 7 -f mpegts - | cat > foo.mpeg
        for i in range(len(paths)):
            paths[i] = paths[i].replace('.png','.jpg')

        if extend == False and os.path.exists(vfile):
            os.unlink(vfile)

        fd = None
        if os.path.exists(vfile) == True:
            fd = os.open(vfile,os.O_WRONLY|os.O_APPEND)
        else:
            fd = os.open(vfile,os.O_WRONLY|os.O_CREAT)

        paths.insert(0,"cat")
        cat = Popen(paths, stdout=PIPE)
        ffmpeg = Popen(['ffmpeg','-f','image2pipe','-r',str(fps),'-c:v','mjpeg','-i','-','-c:v','copy','-f','matroska','-'], stdin=cat.stdout, stdout=fd)
        cat.stdout.close()
        print ffmpeg.communicate()
        os.close(fd)
        paths.pop(0)

        if keeptmpfiles == False:
            for jpg in paths:
                os.unlink(jpg)
                os.unlink(jpg.replace('.jpg','.png'))
        return

    def gifstrategy(self,vfile,paths,keeptmpfiles,extend):
        fps = 30
        loop = 0
        #inputfiles = ' '.join(paths)
        #cmd = "convert -delay {} -loop {} {} {}".format(1/fps,loop,inputfiles,vfile)
        #args = ['convert','-delay',1/fps,'-loop',loop,inputfiles,vfile]
        args = ['convert','-delay',1/fps,'-loop',loop]
        for png in paths:
            args.append(png)
        args.append(vfile)
        call(args)
        #if keeptmpfiles == False:
        #    for png in paths:
        #        os.unlink(png)
        return

    def archiveplots(self):
        filenames = []
        g = self.plot_g()
        for id, (plot) in enumerate(g):
            filenames.append(self.createpng(plot,id))
            # remove any bad files
            if filenames[-1] == None:
                filenames.pop(-1)
            # remove to fully generate archive
            if id > 10000:
                return filenames
        return filenames

    def createvideo(self,archive=True,filenames=[],vfilename='stripvid.apng',extend=False):
        if archive:
            filenames = self.archiveplots()
            print filenames
        videotype = vfilename.split('.')[-1]
        strategy = None
        if videotype == 'apng':
            strategy = self.apngstrategy
        elif videotype == 'avi':
            strategy = self.avistrategy
        elif videotype == 'gif':
            strategy = self.gifstrategy
        else:
            raise ValueError, 'invalid video format [{}]'.format(videotype)
        vpath = os.path.join(self.dirpath, vfilename)
        strategy(vpath,filenames,archive,extend)
        return

################################################################################################
################################################################################################
################################################################################################
################################################################################################

lz = complex(0.25,55)
rz = complex(0.75,55)
lzc = complex(0.25,-55)
rzc = complex(0.75,-55)
def sym_zeros(s):
    # introduce 4 new zeros... just to see what it looks like
    return zeta(s) * (s - lz) * (s - lzc) * (s - rz) * (s - rzc)

def gammareflected(s):
    return gamma(1-s)

def zetaconst(s):
    return 2**s * pi**(s-1)

def gammasin(s):
    return gamma(1-s) * sin(pi*s/2)

def constsin(s):
    return zetaconst(s) * sin(pi*s/2)

def constgamma(s):
    return zetaconst(s) * gamma(1-s)

def zetareflected(s):
    return zeta(1-s)

def zetasin(s):
    return sin( pi * s / 2 )

def alpha(s):
    return zetaconst(s) * zetasin(s) * gamma(1-s)

def zetagammareflected(s):
    return zeta(1-s) * gamma(1-s)

def unitzgr(s):
    return e**(complex(0,arg(zetagammareflected(s))))

def scaledzgr(s):
    z1 = zetagammareflected(complex(1,imag_part(s)))
    return unitzgr(s) / abs(z1)

def contourint(s):
    return 2 * sin(pi * s) * gamma(s) * zeta(s)

def invzetasinpi(s):
    return e**(complex(0,arg(complex(0,0.5) / sin(pi * s))))

def getunit(s):
    return e**(complex(0,arg(s)))

def unitxi(s):
    return getunit(zeta_symmetric(s))

def eta2(s):
    a = 2 * sin(pi * (1-s))
    b = zetagammareflected(s)
    theta = 0.5 * pi * (2*s - 1)
    c = e**(complex(0,theta))
    return a * b * c
    #return 2 * sin(pi * (1-s)) * zeta(1-s) * gamma(1-s) * e**(complex(0,(2*s-1)*pi/2))

print "attempting analysis"
start = datetime.now()
#symzeroanalyzer = ComplexAnalyzer(fn=sym_zeros,dirpath='symzero',filenameformat='symzero_{}.png',xmin=-2000,xmax=2000,ymin=-2000,ymax=2000,tmin=1,tmax=10,tsamplefactor=1/32,dt=0.015625)
#files = symzeroanalyzer.archiveplots()

#za_1 = ComplexAnalyzer(fn=gammareflected,dirpath='gammareflected',filenameformat='gammareflected_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_2 = ComplexAnalyzer(fn=zetasin,dirpath='zetasin',filenameformat='zetasin_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_3 = ComplexAnalyzer(fn=zetaconst,dirpath='zetaconst',filenameformat='zetaconst_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)

#za_4 = ComplexAnalyzer(fn=gammasin,dirpath='gammasin',filenameformat='gammasin_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_5 = ComplexAnalyzer(fn=constsin,dirpath='constsin',filenameformat='constsin_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_6 = ComplexAnalyzer(fn=constgamma,dirpath='constgamma',filenameformat='constgamma_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_7 = ComplexAnalyzer(fn=zetareflected,dirpath='zetareflected',filenameformat='zetareflected_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_8 = ComplexAnalyzer(fn=alpha,dirpath='alpha',filenameformat='alpha_{}.png',tmin=1,tmax=1000,tsamplefactor=1/32)#,dt=0.015625)
#za_9 = ComplexAnalyzer(fn=zetagammareflected,dirpath='zetagammareflected',filenameformat='zetagammareflected_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625)
#za_10 = ComplexAnalyzer(fn=unitzgr,dirpath='unitzgr',filenameformat='unitzgr_{}.png',tmin=100,tmax=250,tsamplefactor=1/32,dt=0.015625,sigmasamplefactor=4)
#za_11 = ComplexAnalyzer(fn=unitzgr,dirpath='unitzgr',filenameformat='unitzgr_{}.png',tmin=100100,tmax=100250,tsamplefactor=1/32,dt=0.015625,sigmasamplefactor=4)
#za_12 = ComplexAnalyzer(xmin=-1000,xmax=1000,ymin=-1000,ymax=1000,fn=scaledzgr,dirpath='scaledzgr',filenameformat='scaledzgr_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625,sigmasamplefactor=4)
#za_13 = ComplexAnalyzer(fn=contourint,dirpath='contourint',filenameformat='contourint_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625,sigmasamplefactor=4)
#za_14 = ComplexAnalyzer(fn=invzetasinpi,dirpath='invzetasinpi',filenameformat='zetasinpi_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625,sigmasamplefactor=4)
#za_15 = ComplexAnalyzer(fn=unitxi,dirpath='unitxi',filenameformat='unitxi_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625,sigmasamplefactor=4)
za_16 = ComplexAnalyzer(fn=eta2,dirpath='eta2',filenameformat='eta2_{}.png',tmin=1,tmax=300,tsamplefactor=1/32)#,dt=0.015625,sigmasamplefactor=4)

#f_1 = za_1.archiveplots()
#f_2 = za_2.archiveplots()
#f_3 = za_3.archiveplots()

#f_4 = za_4.archiveplots()
#f_5 = za_5.archiveplots()
#f_6 = za_6.archiveplots()
#f_7 = za_7.archiveplots()
#f_8 = za_8.archiveplots()
#f_9 = za_9.archiveplots()
#f_10 = za_10.archiveplots()
#f_11 = za_11.archiveplots()
#f_12 = za_12.archiveplots()
#f_13 = za_13.archiveplots()
#f_14 = za_14.archiveplots()
#f_15 = za_15.archiveplots()
f_16 = za_16.archiveplots()

stop = datetime.now()
delta = stop - start
ts = delta.total_seconds()
#print "sym_zero analysis completed in {} s, {} plots/sec".format(ts, len(files)/ts)
#print "analysis completed in {} s, {} plots/sec".format(ts, (len(f_1) + len(f_2) + len(f_3) + len(f_4) + len(f_5) + len(f_6) + len(f_7))/ts)
print "analysis completed in {} s, {} plots/sec".format(ts, (len(f_16))/ts)

print "attempting video creation"
start = datetime.now()
#symzeroanalyzer.createvideo(archive=False,filenames=files,vfilename='symzeros_t_50-60.avi',extend=False)

#za_1.createvideo(archive=False,filenames=f_1,vfilename='gammareflected_t_1-1000.avi',extend=False)
#za_2.createvideo(archive=False,filenames=f_2,vfilename='zetasin_t_1-1000.avi',extend=False)
#za_3.createvideo(archive=False,filenames=f_3,vfilename='zetaconst_t_1-1000.avi',extend=False)

#za_4.createvideo(archive=False,filenames=f_4,vfilename='gammasin_t_1-1000.avi',extend=False)
#za_5.createvideo(archive=False,filenames=f_5,vfilename='constsin_t_1-1000.avi',extend=False)
#za_6.createvideo(archive=False,filenames=f_6,vfilename='constgamma_t_1-1000.avi',extend=False)
#za_7.createvideo(archive=False,filenames=f_7,vfilename='zetareflected_t_1-1000.avi',extend=False)
#za_8.createvideo(archive=False,filenames=f_8,vfilename='alpha_t_1-1000.avi',extend=False)
#za_9.createvideo(archive=False,filenames=f_9,vfilename='alpha_t_1-300.avi',extend=False)
#za_10.createvideo(archive=False,filenames=f_10,vfilename='unitzgr_t_100-250.avi',extend=False)
#za_11.createvideo(archive=False,filenames=f_11,vfilename='unitzgr_t_100100-100250.avi',extend=False)
#za_12.createvideo(archive=False,filenames=f_12,vfilename='scaledzgr_t_1-300.avi',extend=False)
#za_13.createvideo(archive=False,filenames=f_13,vfilename='contourint_t_1-300.avi',extend=False)
#za_14.createvideo(archive=False,filenames=f_14,vfilename='invzetasinpi_t_1-300.avi',extend=False)
#za_15.createvideo(archive=False,filenames=f_15,vfilename='unitxi_t_1-300.avi',extend=False)
za_16.createvideo(archive=False,filenames=f_16,vfilename='eta2_t_1-300.avi',extend=False)

stop = datetime.now()
delta = stop - start
ts = delta.total_seconds()
#print "video creation completed in {} s, {} fps".format(ts, len(files)/ts)
#print "video creation completed in {} s, {} plots/sec".format(ts, (len(f_1) + len(f_2) + len(f_3) + len(f_4) + len(f_5) + len(f_6) + len(f_7))/ts)
print "video creation completed in {} s, {} plots/sec".format(ts, (len(f_16))/ts)

